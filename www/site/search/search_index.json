{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NEON","text":"<p>Live Coding Environment</p> <p>Neon is a Python-based environment for live coding music. You can think of it as a small DAW that you can control with Python code in real-time, fiddling with loops, samples, external synthesizers, effects.</p>"},{"location":"about/","title":"About","text":""},{"location":"architecture/","title":"Architecture","text":"<pre><code>graph LR\n  subgraph Backend\n\n    Neon\n    Rt\n    Dsp\n    Gfx\n\n  end\n\n  subgraph Client\n\n    Agent\n\n  end\n\n  Agent &lt;-- gRPC --&gt; Neon\n  Neon &lt;--&gt; Rt\n  Rt &lt;--&gt; Gfx\n  Neon &lt;--&gt; Dsp\n  Neon &lt;--&gt; Gfx\n  Rt &lt;--&gt; Dsp</code></pre>"},{"location":"architecture/#design-choices","title":"Design Choices","text":""},{"location":"architecture/#patterns","title":"Patterns","text":"<p>Consistency is key as it will become complex with time, some arbitrary patterns we are using:</p> <ul> <li>Threads are handled by the object and not the caller</li> <li>Threads implement <code>Init/Start/Stop</code> pattern</li> </ul>"},{"location":"architecture/#runtime-routines","title":"Runtime Routines","text":""},{"location":"architecture/#sync-outside-of-loops","title":"Sync outside of loops","text":"<p>Synchronuous routines that take time should not happen within loop, as they will screw the timing of events. Prefer allowing them in the global context: they might only delay evaluation of the next loop update, which will have the loops repeat once more for their duration but without being a total disaster.</p> <p>Examples:</p> <ul> <li>loading a sample directory</li> <li>getting the list of samples</li> <li>creating a websocket or a Unix thread</li> </ul>"},{"location":"architecture/#async-from-loops","title":"Async from loops","text":"<p>Conversely, events going from loops should use MIDI as they are async and return immediately, later on we can add timing information into them and properly handle eventual interpretation lag.</p> <p>Examples:</p> <ul> <li>playing a specific sample via MIDI</li> </ul>"},{"location":"guides/intro/","title":"Intro","text":""},{"location":"guides/intro/#first-loop","title":"First Loop","text":"<p>Now that we have tracks, we can schedule loops on them.</p> <pre><code>@loop\ndef hello_world():\n    log('Hello World')\n</code></pre>"},{"location":"guides/intro/#instruments","title":"Instruments","text":""},{"location":"guides/intro/#samples","title":"Samples","text":""},{"location":"guides/intro/#external-instrument","title":"External Instrument","text":""},{"location":"guides/intro_hello/","title":"Hello World","text":"<p>The idea behind live coding is to write and evaluate code to change a system incrementally. Let's do our very first session, go in the Neon <code>live</code> directory and with your favourite editor, open the file <code>hello.py</code>:</p> <pre><code># NEON session\n\nlog('Hello World')\n</code></pre> <p>Neon is watching this directory and whenever something changes in one of its files, it will re-evaluate the file. So you can go ahead and save the file. As expected it shows <code>Hello World</code> in the Neon console.</p> <p>Let's change the code to:</p> <pre><code># NEON session\n\nfor i in range(42):\n    log(f'Hello World {i}')\n</code></pre> <p>Upon save, it evaluates the file and you'll see plenty of hello worlds. The <code>live</code> folder is the primary area in which you work, you can define your libraries of facilities there, prepare your helper functions, and so on.</p> <p>Note</p> <p>Files are loaded in alphabetical order in the <code>live</code> folder, so you can take advantage of this and have your helpers, facilities always loaded in a file prefixed with <code>_</code> for instance.</p> <p>Now, let's prepare something more useful.</p>"},{"location":"guides/intro_tracks/","title":"Your First Track","text":"<p>The model of Neon is similar to Digital Audio Workstations (a.k.a DAWs) where a track is identified by an instrument and a channel number which is used to control the track via MIDI devices. In this example, we setup two tracks:</p> <ul> <li>a sampler track that can play samples and be controlled on MIDI channel 0,</li> <li>an external MIDI instrument which can be controlled on MIDI channel 1.</li> </ul> <pre><code>tracks.setup([\n    tracks.mk('mono_sampler', 0),\n    tracks.mk('midi_ext', 1),\n])\n</code></pre> <p>In the same fashion as with the hello world example, this code can be updated dynamically, new tracks can be added or removed automatically from this list. This is how you can for instance progressively move from an ambient track playing pad samples to something more groovy by introducing a new track for drums.</p> <p>The tracks can be setup by accessing facilities from the tracks module: this is because Neon is organized in modules, each targetting a specific area.</p> <p>As we previously encountered with the log facilitiy, some keywords globally accessible. Their list is limited.</p> <p>You can print the current layout of tracks using:</p>"},{"location":"reference/bpm/","title":"bpm","text":""},{"location":"reference/bpm/#neon.bpm","title":"<code>bpm</code>","text":"<p>Push the tempo.</p> <p>The bpm module provides a way to set the tempo of the current session. The tempo is a global setting that affects all loops and samples, it is measured in beats per minute (BPM) and can be adjusted in real-time.</p>"},{"location":"reference/bpm/#neon.bpm--cookbook","title":"Cookbook","text":""},{"location":"reference/bpm/#neon.bpm--set-the-tempo","title":"Set the tempo","text":"<pre><code>bpm.set(120)\n</code></pre>"},{"location":"reference/bpm/#neon.bpm--get-the-current-tempo","title":"Get the current tempo","text":"<pre><code>tempo = bpm.get()\n</code></pre>"},{"location":"reference/bpm/#neon.bpm--get-the-current-beat","title":"Get the current beat","text":"<pre><code>beat = bpm.beat()\n</code></pre>"},{"location":"reference/bpm/#neon.bpm--reference","title":"Reference","text":""},{"location":"reference/bpm/#neon.bpm.beat","title":"<code>beat()</code>","text":"<p>Get the current beat.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current beat.</p>"},{"location":"reference/bpm/#neon.bpm.get","title":"<code>get()</code>","text":"<p>Get the BPM. This function can only be called from the global    scope.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current BPM.</p> <p>Raises:</p> Type Description <code>InLoopException</code> <p>If called from inside a loop.</p>"},{"location":"reference/bpm/#neon.bpm.set","title":"<code>set(bpm)</code>","text":"<p>Set the BPM. This function can only be called from the global    scope.</p> <p>Parameters:</p> Name Type Description Default <code>bpm</code> <code>float</code> <p>The new BPM.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The new BPM.</p> <p>Raises:</p> Type Description <code>InLoopException</code> <p>If called from inside a loop.</p>"},{"location":"reference/errors/","title":"errors","text":""},{"location":"reference/errors/#neon.errors","title":"<code>errors</code>","text":"<p>Exception is not the rule.</p> <p>The errors module contains exceptions raised by the Neon engine to signal errors at runtime.</p>"},{"location":"reference/errors/#neon.errors.InLoopException","title":"<code>InLoopException</code>","text":"<p>             Bases: <code>NeonException</code></p> <p>Raised when trying to execute code inside a live context.</p> <p>In Neon, some of the code is expected to be used from the global scope as it affects everything, for example, setting the BPM. This exception is raised if such code is called from a loop.</p>"},{"location":"reference/errors/#neon.errors.NeonException","title":"<code>NeonException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for Neon exceptions.</p>"},{"location":"reference/errors/#neon.errors.NotInLoopException","title":"<code>NotInLoopException</code>","text":"<p>             Bases: <code>NeonException</code></p> <p>Raised when trying to execute code outside of a live context.</p> <p>In Neon, some of the code is expected to be used from within a loop or a live function, for instance sleeping between two instructions. This exception is raised if such code is called from the global scope.</p>"},{"location":"reference/midi/","title":"midi","text":""},{"location":"reference/midi/#neon.midi","title":"<code>midi</code>","text":"<p>Insert a joke here.</p> <p>The midi module provides a way to communicate with external synthesizers.</p>"},{"location":"reference/midi/#neon.midi--cookbook","title":"Cookbook","text":"<pre><code>midi.note_on(60)\nmidi.note_off(60)\n</code></pre>"},{"location":"reference/midi/#neon.midi--reference","title":"Reference","text":""},{"location":"reference/midi/#neon.midi.note_off","title":"<code>note_off(note, velocity=127)</code>","text":"<p>Send the MIDI note off to the external synthesizer using the track id of the loop as MIDI channel.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>int</code> <p>The MIDI note to stop.</p> required <code>velocity</code> <code>int</code> <p>The velocity. Defaults to 127.</p> <code>127</code> <p>Raises:</p> Type Description <code>NotInLoopException</code> <p>If called from outside a loop.</p>"},{"location":"reference/midi/#neon.midi.note_on","title":"<code>note_on(note, velocity=127)</code>","text":"<p>Send the MIDI note to the external synthesizer using the track id of the loop as MIDI channel.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>int</code> <p>The MIDI note to send.</p> required <code>velocity</code> <code>int</code> <p>The velocity. Defaults to 127.</p> <code>127</code> <p>Raises:</p> Type Description <code>NotInLoopException</code> <p>If called from outside a loop.</p>"},{"location":"reference/neon/","title":"neon","text":""},{"location":"reference/neon/#neon","title":"<code>neon</code>","text":"<p>This is your last chance. After this, there is no turning back.</p> Info <p>The neon module is the execution context in which music code is written and scheduled: it does not need to be referenced and all the facilities are accessible directly.</p> <p>The neon module is the base for the Neon environment and is the context in which you will write and schedule your music code. It contains a small set of facilities detailed in this as well as more specialized modules which can be accessed by their names.</p>"},{"location":"reference/neon/#neon--cookbook","title":"Cookbook","text":""},{"location":"reference/neon/#neon--minimalistic-kicksnare-track","title":"Minimalistic kick/snare track","text":"<pre><code># Set the global BPM.\nbpm.set(120)\n\n# Define 1 track with a sampler as an instrument.\ntracks.setup([\n    tracks.mk(\"sampler\", 1, muted=False, volume=100),\n])\n\n# Create a sampler instance using the sample pack 'passage'.\ns = sampler.new('passage')\n\n# Define a 4 beats loop that plays a kick sample every beat on track 1.\n@loop(beats=4, track=1)\ndef kick():\n    for i in range(4):\n        s.play('kick')\n        sleep(1)\n\n# Define a 2 beats loop that plays a snare sample every 2 beats on track 1.\n@loop(beats=2, track=1)\ndef snare():\n    for i in range(2):\n        s.play('snare')\n        sleep(2)\n</code></pre>"},{"location":"reference/neon/#neon--reference","title":"Reference","text":""},{"location":"reference/neon/#neon.live","title":"<code>live()</code>","text":"<p>Decorator to create a live function that is executed each time the code is changed.</p> <pre><code>@live\ndef setup:\n  tracks.setup([\n    tracks.mk(\"sampler\", 1, muted=False, volume=100),\n  ])\n</code></pre> <p>Returns:</p> Type Description <code>callable</code> <p>A decorator registering and executing the live function.</p>"},{"location":"reference/neon/#neon.log","title":"<code>log(message)</code>","text":"<p>Log a message to the console.</p> <p>This function is used to log messages to the console. It is useful for debugging purposes.</p> <pre><code>log(f'We are at beat {bpm.beat()}')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required"},{"location":"reference/neon/#neon.loop","title":"<code>loop(beats=4, track=1, align=4)</code>","text":"<p>Decorator to create a loop that is rescheduled every given number of beats.</p> <p>The concept of a loop is similar to Sonic Pi's live loops. Code within a loop is executed using temporal recursion, and can updated in real-time: the next run of the loop will execute the updated version. This provides a way to incrementally build audio performances.  by editing code.  Few rules need to be followed for code in live-loops: it should not be blocking as it would block the main thread. For this reason, blocking facilities such are sleep are provided by the engine.</p> <pre><code>@loop\ndef my_loop(beats=4, track=1):\n  log(\"Hello World\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>beats</code> <code>int</code> <p>The duration of the loop in beats.</p> <code>4</code> <code>track</code> <code>int</code> <p>The track to use.</p> <code>1</code> <code>align</code> <code>int</code> <p>The alignment of the loop in beats.</p> <code>4</code> <p>Returns:</p> Type Description <code>callable</code> <p>A decorator registering and scheduling the function in a loop.</p>"},{"location":"reference/neon/#neon.sleep","title":"<code>sleep(beats)</code>","text":"<p>Sleep for the given duration in beats in the current loop.</p> <p>In this example, we define a 4-beats loop that plays a kick sample every beats, and sleeps for 1 beat between each sample.</p> <pre><code>@loop\ndef my_loop(beats=4, track=1):\n   for i in range(4):\n      s.play('kick')\n      sleep(1)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>beats</code> <code>float</code> <p>The duration to sleep in beats.</p> required <p>Raises:</p> Type Description <code>NotInLiveLoopException</code> <p>If we are not in a loop.</p>"},{"location":"reference/sampler/","title":"sampler","text":""},{"location":"reference/sampler/#neon.sampler","title":"<code>sampler</code>","text":"<p>Samples, lots of samples.</p> Info <p>The sampler module can be used on loops running on tracks with instrument type set to <code>sampler</code>.</p> <p>The sampler module provides a way to load samples and play them inside loops in an intuitive way. Once instantiated, a <code>Sampler</code> can be used to play samples from the selected pack given their name. If no exact match of the sample name is found, the first matching sample is selected. The cost of creating and using a sampler is cheap so it is fine to have a lot of instances at once.</p>"},{"location":"reference/sampler/#neon.sampler--cookbook","title":"Cookbook","text":""},{"location":"reference/sampler/#neon.sampler--play-samples","title":"Play samples","text":"<pre><code>s = sampler.new('808')\n\n@loop\ndef kick(beats=4):\n  for i in range(4):\n    s.play('kick')\n    sleep(1)\n</code></pre>"},{"location":"reference/sampler/#neon.sampler--list-available-packs","title":"List available packs","text":"<pre><code>packs = sampler.packs()\n</code></pre>"},{"location":"reference/sampler/#neon.sampler--list-samples-in-a-pack","title":"List samples in a pack","text":"<pre><code>samples = sampler.samples('808')\n</code></pre>"},{"location":"reference/sampler/#neon.sampler--reference","title":"Reference","text":""},{"location":"reference/sampler/#neon.sampler.Sample","title":"<code>Sample(name, pack, path, duration)</code>  <code>dataclass</code>","text":"<p>A sample is a sound file that can be played by a sampler. It has a name, a pack, a path, and a duration. The name is the identifier used to play the sample, the pack is the name of the pack the sample belongs to, the path is the location of the sample file, and the duration is the length of the sample in seconds.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the sample.</p> <code>pack</code> <code>str</code> <p>The name of the pack.</p> <code>path</code> <code>str</code> <p>The location of the sample file.</p> <code>duration</code> <code>float</code> <p>The length of the sample in seconds.</p>"},{"location":"reference/sampler/#neon.sampler.Sampler","title":"<code>Sampler(pack_name)</code>","text":"<p>Creates a new sampler with samples from the designated pack.</p> Note <p>You can create a Sampler via the shortcut <code>n.sampler.new()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pack_name</code> <code>str</code> <p>The name of the sample pack to use.</p> required"},{"location":"reference/sampler/#neon.sampler.Sampler.play","title":"<code>play(name, loop=False, length=None, start=0.0, rev=False)</code>","text":"<p>Plays a sample by its given name. If there is no exact match, attempts to find one that contains the name (for example, 'kick' will match 'hard-kick'). If the selected sample is already being played, enqueues a new one, allowing to play simultaneously multiple times the same sample.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the sample.</p> required <code>loop</code> <code>bool</code> <p>Whether to loop the sample or not. If the sample is looping, it will play forever unless a length is specified, or it is explictly stopped.</p> <code>False</code> <code>length</code> <code>float | None</code> <p>Duration in seconds. If None, the sample is played for its entired duration.</p> <code>None</code> <code>start</code> <code>float</code> <p>When to start playing the sample in seconds.</p> <code>0.0</code> <code>rev</code> <code>bool</code> <p>Whether to reverse the sample or not.</p> <code>False</code>"},{"location":"reference/sampler/#neon.sampler.Sampler.stop","title":"<code>stop(name)</code>","text":"<p>Stops playing the sample. If there is no exact match, attempts to find one that contains the name (for example, 'kick' will match 'hard-kick'). If the same sample is currently played multiple times, the latest one is selected to stop (LIFO).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the sample.</p> required"},{"location":"reference/sampler/#neon.sampler.new","title":"<code>new(pack_name)</code>","text":"<p>Creates a new sampler with samples from the designated pack.</p> <p>Parameters:</p> Name Type Description Default <code>pack_name</code> <code>str</code> <p>The name of the sample pack to use.</p> required"},{"location":"reference/sampler/#neon.sampler.packs","title":"<code>packs()</code>","text":"<p>Returns the list of available sample packs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>The list of loaded sample packs.</p>"},{"location":"reference/sampler/#neon.sampler.samples","title":"<code>samples(pack_name)</code>","text":"<p>Returns the list of samples available in the given pack.</p> <p>Parameters:</p> Name Type Description Default <code>pack_name</code> <code>str</code> <p>The name of the sample pack.</p> required <p>Returns:</p> Type Description <code>list[Sample]</code> <p>The list of samples from the sample pack.</p>"},{"location":"reference/tracks/","title":"tracks","text":""},{"location":"reference/tracks/#neon.tracks","title":"<code>tracks</code>","text":"<p>Track them all.</p> <p>The <code>tracks</code> module provides a way to setup and control tracks in the neon engine. A track has an instrument type and a set of parameters and effects. Once a track is created, loops can be scheduled on it. Tracks can be added &amp; removed in real-time using the <code>setup()</code> function, existing tracks are untouched.</p>"},{"location":"reference/tracks/#neon.tracks--cookbook","title":"Cookbook","text":""},{"location":"reference/tracks/#neon.tracks--setup-tracks","title":"Setup tracks","text":"<pre><code>tracks.setup([\n    tracks.mk('sampler', 0),\n    tracks.mk('sampler', 1),\n    tracks.mk('sampler', 2),\n])\n</code></pre>"},{"location":"reference/tracks/#neon.tracks--get-current-tracks","title":"Get current tracks","text":"<pre><code>trks = tracks.layout()\n</code></pre>"},{"location":"reference/tracks/#neon.tracks--reference","title":"Reference","text":""},{"location":"reference/tracks/#neon.tracks.Track","title":"<code>Track(instrument=None, channel=None, muted=None, volume=None, pan=None, extra=None)</code>  <code>dataclass</code>","text":"<p>Representation of a Neon track.</p> <p>Attributes:</p> Name Type Description <code>instrument</code> <code>str</code> <p>The instrument type.</p> <code>channel</code> <code>int</code> <p>The channel.</p> <code>muted</code> <code>bool | None</code> <p>The muted state. Defaults to None.</p> <code>volume</code> <code>float | None</code> <p>The volume. Defaults to None.</p> <code>pan</code> <code>float | None</code> <p>The pan. Defaults to None.</p> <code>extra</code> <code>dict | None</code> <p>Extra parameters. Defaults to None.</p>"},{"location":"reference/tracks/#neon.tracks.layout","title":"<code>layout()</code>","text":"<p>Get the current tracks.</p> <p>Returns:</p> Type Description <code>list[Track]</code> <p>list[Track]: The current tracks.</p> <p>Raises:</p> Type Description <code>InLoopException</code> <p>If called from inside a loop.</p>"},{"location":"reference/tracks/#neon.tracks.mk","title":"<code>mk(instrument, channel, muted=None, volume=None, pan=None)</code>","text":"<p>Creates a new track.</p> <p>Parameters:</p> Name Type Description Default <code>instrument</code> <code>str</code> <p>The instrument type.</p> required <code>channel</code> <code>int</code> <p>The channel.</p> required <code>muted</code> <code>bool</code> <p>The muted state. Defaults to None.</p> <code>None</code> <code>volume</code> <code>float</code> <p>The volume. Defaults to None.</p> <code>None</code> <code>pan</code> <code>float</code> <p>The pan. Defaults to None.</p> <code>None</code>"},{"location":"reference/tracks/#neon.tracks.setup","title":"<code>setup(tracks)</code>","text":"<p>Setup tracks.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>list[Track]</code> <p>The tracks to setup.</p> required <p>Raises:</p> Type Description <code>InLoopException</code> <p>If called from inside a loop.</p>"}]}